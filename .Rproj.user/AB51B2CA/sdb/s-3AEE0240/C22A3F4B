{
    "contents" : "stars2 <- function (x, full = TRUE, scale = TRUE, radius = TRUE, labels = dimnames(x)[[1L]], \n          locations = NULL, nrow = NULL, ncol = NULL, len = 1, key.loc = NULL, \n          key.labels = dimnames(x)[[2L]], key.xpd = TRUE, xlim = NULL, \n          ylim = NULL, flip.labels = NULL, draw.segments = FALSE, col.segments = 1L:n.seg, \n          col.stars = NA, col.lines = NA, axes = FALSE, frame.plot = axes, \n          main = NULL, sub = NULL, xlab = \"\", ylab = \"\", cex = 0.8, \n          lwd = 0.25, lty = par(\"lty\"), xpd = FALSE, mar = pmin(par(\"mar\"), \n                                                                1.1 + c(2 * axes + (xlab != \"\"), 2 * axes + (ylab != \n                                                                                                               \"\"), 1, 0)), add = FALSE, plot = TRUE, ...) \n{\n  if (is.data.frame(x)) \n    x <- data.matrix(x)\n  else if (!is.matrix(x)) \n    stop(\"'x' must be a matrix or a data frame\")\n  if (!is.numeric(x)) \n    stop(\"data in 'x' must be numeric\")\n  n.loc <- nrow(x)\n  n.seg <- ncol(x)\n  if (is.null(locations)) {\n    if (is.null(nrow)) \n      nrow <- ceiling(if (!is.numeric(ncol)) sqrt(n.loc) else n.loc/ncol)\n    if (is.null(ncol)) \n      ncol <- ceiling(n.loc/nrow)\n    if (nrow * ncol < n.loc) \n      stop(\"'nrow * ncol' is less than the number of observations\")\n    ff <- if (!is.null(labels)) \n      2.3\n    else 2.1\n    locations <- expand.grid(ff * 1L:ncol, ff * nrow:1)[1L:n.loc, \n                                                        ]\n    if (!is.null(labels) && (missing(flip.labels) || !is.logical(flip.labels))) \n      flip.labels <- ncol * mean(nchar(labels, type = \"c\")) > \n      30\n  }\n  else {\n    if (is.numeric(locations) && length(locations) == 2) {\n      locations <- cbind(rep.int(locations[1L], n.loc), \n                         rep.int(locations[2L], n.loc))\n      if (!missing(labels) && n.loc > 1) \n        warning(\"labels do not make sense for a single location\")\n      else labels <- NULL\n    }\n    else {\n      if (is.data.frame(locations)) \n        locations <- data.matrix(locations)\n      if (!is.matrix(locations) || ncol(locations) != 2) \n        stop(\"'locations' must be a 2-column matrix.\")\n      if (n.loc != nrow(locations)) \n        stop(\"number of rows of 'locations' and 'x' must be equal.\")\n    }\n    if (missing(flip.labels) || !is.logical(flip.labels)) \n      flip.labels <- FALSE\n  }\n  xloc <- locations[, 1]\n  yloc <- locations[, 2]\n  angles <- if (full) \n    seq.int(0, 2 * pi, length.out = n.seg + 1)[-(n.seg + \n                                                   1)]\n  else if (draw.segments) \n    seq.int(0, pi, length.out = n.seg + 1)[-(n.seg + 1)]\n  else seq.int(0, pi, length.out = n.seg)\n  if (length(angles) != n.seg) \n    stop(\"length of 'angles' must equal 'ncol(x)'\")\n  if (scale) {\n    x <- apply(x, 2L, function(x) (x - min(x, na.rm = TRUE))/diff(range(x, \n                                                                        na.rm = TRUE)))\n  }\n  x[is.na(x)] <- 0\n  mx <- max(x <- x * len)\n  if (is.null(xlim)) \n    xlim <- range(xloc) + c(-mx, mx)\n  if (is.null(ylim)) \n    ylim <- range(yloc) + c(-mx, mx)\n  deg <- pi/180\n  op <- par(mar = mar, xpd = xpd)\n  on.exit(par(op))\n  dev.hold()\n  on.exit(dev.flush(), add = TRUE)\n  if (plot && !add) \n    plot(0, type = \"n\", ..., xlim = xlim, ylim = ylim, main = main, \n         sub = sub, xlab = xlab, ylab = ylab, asp = 1, axes = axes)\n  if (!plot) \n    return(locations)\n  s.x <- xloc + x * rep.int(cos(angles), rep.int(n.loc, n.seg))\n  s.y <- yloc + x * rep.int(sin(angles), rep.int(n.loc, n.seg))\n  if (draw.segments) {\n    aangl <- c(angles, if (full) 2 * pi else pi)\n    for (i in 1L:n.loc) {\n      px <- py <- numeric()\n      for (j in 1L:n.seg) {\n        k <- seq.int(from = aangl[j], to = aangl[j + \n                                                   1], by = 1 * deg)\n        px <- c(px, xloc[i], s.x[i, j], x[i, j] * cos(k) + \n                  xloc[i], NA)\n        py <- c(py, yloc[i], s.y[i, j], x[i, j] * sin(k) + \n                  yloc[i], NA)\n      }\n      polygon(px, py, col = col.segments, lwd = lwd, lty = lty)\n    }\n  }\n  else {\n    for (i in 1L:n.loc) {\n      polygon(s.x[i, ], s.y[i, ], lwd = lwd, lty = lty, \n              border = col.lines[i], col = col.stars[i])\n      polygon(s.x[i, ], s.y[i, ], lwd = lwd, lty = lty, \n              border = col.lines[i], col = col.stars[i])\n      if (radius) \n        segments(rep.int(xloc[i], n.seg), rep.int(yloc[i], \n                                                  n.seg), s.x[i, ], s.y[i, ], lwd = lwd, lty = lty)\n    }\n  }\n  if (!is.null(labels)) {\n    y.off <- mx * (if (full) \n      1\n      else 0.1)\n    if (flip.labels) \n      y.off <- y.off + cex * par(\"cxy\")[2L] * ((1L:n.loc)%%2 - \n                                                 if (full) \n                                                   0.4\n                                               else 0)\n    text(xloc, yloc - y.off, labels, cex = cex, adj = c(0.5, \n                                                        1))\n  }\n  if (!is.null(key.loc)) {\n    par(xpd = key.xpd)\n    key.x <- len * cos(angles) + key.loc[1L]\n    key.y <- len * sin(angles) + key.loc[2L]\n    if (draw.segments) {\n      px <- py <- numeric()\n      for (j in 1L:n.seg) {\n        k <- seq.int(from = aangl[j], to = aangl[j + \n                                                   1], by = 1 * deg)\n        px <- c(px, key.loc[1L], key.x[j], len * cos(k) + \n                  key.loc[1L], NA)\n        py <- c(py, key.loc[2L], key.y[j], len * sin(k) + \n                  key.loc[2L], NA)\n      }\n      polygon(px, py, col = col.segments, lwd = lwd, lty = lty)\n    }\n    else {\n      polygon(key.x, key.y, lwd = lwd, lty = lty)\n      if (radius) \n        segments(rep.int(key.loc[1L], n.seg), rep.int(key.loc[2L], \n                                                      n.seg), key.x, key.y, lwd = lwd, lty = lty)\n    }\n    lab.angl <- angles + if (draw.segments) \n      (angles[2L] - angles[1L])/2\n    else 0\n    label.x <- 1.1 * len * cos(lab.angl) + key.loc[1L]\n    label.y <- 1.1 * len * sin(lab.angl) + key.loc[2L]\n    for (k in 1L:n.seg) {\n      text.adj <- c(if (lab.angl[k] < 90 * deg || lab.angl[k] > \n                          270 * deg) 0 else if (lab.angl[k] > 90 * deg && \n                                                  lab.angl[k] < 270 * deg) 1 else 0.5, if (lab.angl[k] <= \n                                                                                             90 * deg) (1 - lab.angl[k]/(90 * deg))/2 else if (lab.angl[k] <= \n                                                                                                                                                 270 * deg) (lab.angl[k] - 90 * deg)/(180 * deg) else 1 - \n                      (lab.angl[k] - 270 * deg)/(180 * deg))\n      text(label.x[k], label.y[k], labels = key.labels[k], \n           cex = cex, adj = text.adj)\n    }\n  }\n  if (frame.plot) \n    box(...)\n  invisible(locations)\n}",
    "created" : 1411348929759.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2642796523",
    "id" : "C22A3F4B",
    "lastKnownWriteTime" : 1411349177,
    "path" : "C:/Users/PujaAnchlia/dm-proj-1/src/stars2.R",
    "project_path" : "src/stars2.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : true,
    "type" : "r_source"
}